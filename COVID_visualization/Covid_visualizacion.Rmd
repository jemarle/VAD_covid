---
title: "Proyecto Visualizacion Covid"
author: "dfa Vicente Martínez"
date: "2024-02-14"
output: html_document
---

```{r}
library(ggmap)
# library(rgdal)
library(dplyr)
library(tidyr)
library(tmap)
library(geospatial)
library(maps)
library(raster)
library(tmaptools)
library(leaflet)
library(geojsonio)
library(leaflet)
library(ggplot2)
library(shiny)
library(shinydashboard)
```

```{r }
covid_hospitalizations_raw <- read.csv("./data/owid-covid-data.csv") #el pesado.
#covid_hospitalizations_raw <- read.csv("./data/covid-hospitalizations.csv")

data("World")
```

```{r}
covid_hospitalizations <- covid_hospitalizations_raw %>%
  mutate(date = as.Date(date)) %>%
  # Filtrar para que la fecha esté entre 2020-01-01 y 2021-01-01
  #dplyr::filter(date >= "2020-01-01" & date <= "2024-01-01") %>%
  # Seleccionar columnas específicas
  #dplyr::select(iso_code, location, date, total_cases, total_cases_per_million, new_cases_per_million, total_deaths, new_deaths, icu_patients_per_million, weekly_icu_admissions_per_million, weekly_hosp_admissions_per_million, total_tests_per_thousand) %>%
  # Convertir a formato largo
  dplyr::select(-tests_units) %>%
  pivot_longer(cols = -c(1:4), 
               names_to = "indicator", 
               values_to = "value")
```

```{r}
initial_value <- "total_cases"

my_palette <- colorRampPalette(c("lightyellow", "darkgreen"))(6)

#filtered_legend <- covid_hospitalizations %>%
#  dplyr::filter(indicator == initial_value)

# UI code
ui <- dashboardPage(
  dashboardHeader(title = "COVID-19 App"),
  dashboardSidebar(
    sidebarMenu(
      menuItem("Visualización de indicadores", tabName = "page1", icon = icon("stats", lib = "glyphicon"))
    )
  ),
  dashboardBody(
    tabItems(
      # Home page
      # Page 1 content
      tabItem(tabName = "page1",
              fluidRow(
                column(width = 4,
                       selectInput("indicator_selector", "Selecciona el indicador a representar:",
                                   choices = unique(covid_hospitalizations$indicator))),
                column(width = 4,
                       uiOutput("date_slider_ui")),
                column(width = 4,
                       selectInput("continent", "Selecciona un continente:",
                                   choices = c("World", "Africa", "Asia", "Europe", "North America", "Oceania", "South America"))
                )
              ),
              fluidRow(
                column(width = 4),
                column(width = 4,
                       uiOutput("interval_slider_ui")),  # Añadido el uiOutput para el sliderInput del intervalo
                column(width = 4),
                column(width = 4,
                       uiOutput("step_slider_ui")),  # Añadido el uiOutput para el sliderInput del paso
                column(width = 12,
                       actionButton("save_date_button", "Guardar como fecha inicial"))  # Botón para guardar la fecha inicial
              ),
              fluidRow(
                leafletOutput("my_tmap", width = "100%")  # Ajustar el ancho del mapa al 100%
              ),
              fluidRow(
                box(column(width = 12,
                            plotOutput("selected_country_plot")), width = 12))
              
      )
      
        )
      )
    )
  


# Server code (not necessary for this example)
# Server code (no es necesario para este ejemplo)
server <- function(input, output, session) {
  output$informacion_covid <- renderUI({
  })
  
  # Crear un valor reactivo para almacenar la fecha inicial
  initial_date <- reactiveVal(as.Date("2020-01-06"))
  
  output$informacion_covid <- renderUI({
  })
  
  observe({
    # Filter available dates based on selected indicator
    selected_indicator <- input$indicator_selector
  })
  
  output$date_slider_ui <- renderUI({
    sliderInput("date_slider", label = "Selecciona la fecha:",
                min = as.Date("2020-01-06"),
                max = as.Date("2024-01-01"),
                value = initial_date(),  # Utilizar la fecha inicial almacenada
                step = 1,
                animate = animationOptions(
                  interval = input$interval_slider,  # Utiliza el valor del intervalo del slider
                  loop = FALSE,
                  playButton = NULL,
                  pauseButton = NULL
                )
    )
  })
  
  # Agrega el sliderInput para controlar el intervalo
  output$interval_slider_ui <- renderUI({
    sliderInput("interval_slider", label = "Selecciona el intervalo de actualización para la animación (en ms). ⚠️ Valores bajos pueden no ser soportados por su equipo.",
                min = 500,
                max = 5000,
                value = 1000,
                step = 100)
  })
  
  # Observar el botón para guardar la fecha inicial
  observeEvent(input$save_date_button, {
    initial_date(input$date_slider)  # Guardar la fecha actual del slider como fecha inicial
  })
  
  observeEvent(input$continent, {
  # Define coordinates for each continent
  continent_coords <- list(
    World = c(0, -20),
    Africa = c(0, 20),
    Asia = c(35, 100),
    Europe = c(50, 10),
    "North America" = c(40, -100),
    Oceania = c(-25, 135),
    "South America" = c(-10, -60)
  )
  
  # Get selected continent coordinates
  coords <- continent_coords[[input$continent]]
  
  # Set default zoom
  zoom <- 2.5
  
  # Adjust zoom if continent is "World"
  if (input$continent == "World") {
    zoom <- 1
  }
  
  # Update map view to zoom to the selected continent
  leafletProxy("my_tmap") %>%
    setView(lng = coords[2], lat = coords[1], zoom = zoom)
})
  
  output$my_tmap <- renderTmap({
    data("World")
    
    # Filter data based on selected continent
    continent <- input$continent
    if (continent != "World") {
      World <- World[World$continent == continent, ]
    }
    
    tm_shape(World, projection = "+proj=robin") +
      tm_borders(zindex = 666)
  })
  
  observeEvent(c(input$indicator_selector, input$date_slider, input$continent), {
    req(input$indicator_selector, input$date_slider, input$continent)
    
    # Filter data based on selected indicator and date
    selected_indicator <- input$indicator_selector
    selected_date <- input$date_slider
    continent <- input$continent

    filtered_data <- covid_hospitalizations %>%
      filter(indicator == selected_indicator & date == selected_date)

    
    if (continent != "World") {
      filtered_data <- filtered_data %>%
        dplyr::filter(continent == continent)
      
      World <- World[World$continent == continent, ]
    }
    
    World_dataset <- inner_join(World, filtered_data, by = c("name" = "location"))

    tmapProxy("my_tmap", session, {
      tm_remove_layer(666) +
        tm_shape(World_dataset, projection = "+proj=robin") + 
        tm_polygons("value", legend.title = selected_indicator, palette = my_palette, zindex = 666) + 
        tm_style("cobalt")
    })
  })
  
  output$selected_country_plot <- renderPlot({
    req(input$my_tmap_shape_click)
    
    # Get clicked country
    clicked_country <- input$my_tmap_shape_click$id
    
    # Filter data for the selected country
    selected_indicator <- input$indicator_selector
    
    selected_country_data <- covid_hospitalizations %>%
      filter(iso_code == clicked_country & indicator == selected_indicator)
    selected_country_data$date <- as.Date(selected_country_data$date)
    
    # Plot time series
    ggplot(selected_country_data, aes(x = date, y = value)) +
      geom_line() + 
      labs(title = paste("Serie temporal de", clicked_country),
           x = "Fecha", y = selected_indicator) +
      scale_x_date(date_breaks = "1 month", date_labels = "%Y-%m-%d") +
      theme(axis.text.x = element_text(angle = 45, hjust = 1))
  })
}

# Ejecutar la aplicación
shinyApp(ui, server)
```


